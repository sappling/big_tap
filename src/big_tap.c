/*

   Big Time watch

   A digital watch with large digits.


   A few things complicate the implementation of this watch:

   a) The largest size of the Nevis font which the Pebble handles
      seems to be ~47 units (points or pixels?). But the size of
      characters we want is ~100 points.

      This requires us to generate and use images instead of
      fonts--which complicates things greatly.

   b) When I started it wasn't possible to load all the images into
      RAM at once--this means we have to load/unload each image when
      we need it. The images are slightly smaller now than they were
      but I figured it would still be pushing it to load them all at
      once, even if they just fit, so I've stuck with the load/unload
      approach.

 */

#include "pebble.h"
#include "tap.h"

static Window *window;
static Layer *firstLayer;
static InverterLayer *inverterLayer = NULL;
static TextLayer *dayLayer;
static char dayText[3];

//
// There's only enough memory to load about 6 of 10 required images
// so we have to swap them in & out...
//
// We have one "slot" per digit location on screen.
//
// Because layers can only have one parent we load a digit for each
// slot--even if the digit image is already in another slot.
//
// Slot on-screen layout:
//     0 1
//     2 3
//
#define TOTAL_IMAGE_SLOTS 4

#define NUMBER_OF_IMAGES 10

//#define HEIGHT 168
//#define WIDTH 144
#define DATE_OFFSET 5

/*
enum {
  PERSIST_KEY_BACKGROUND = 0x0,
  PERSIST_KEY_SHOW_DAY = 0x1
};
*/

//#define PERSIST_KEY_BACKGROUND 0
//#define PERSIST_KEY_SHOW_DAY 1

const uint32_t PERSIST_KEY_BACKGROUND = 0;
const uint32_t PERSIST_KEY_SHOW_DAY = 1;

enum {
  MSG_KEY_BACKGROUND = 0x0,
  MSG_KEY_SHOW_DAY = 0x1,
  MSG_KEY_REQ_VALUES = 0x2
};
                              
// defaults to black background
#define DEFAULT_BACKGROUND 1
#define DEFAULT_SHOWDAY 1

// These images are 72 x 84 pixels (i.e. a quarter of the display),
// black and white with the digit character centered in the image.
// (As generated by the `fonttools/font2png.py` script.)
const int IMAGE_RESOURCE_IDS_72[NUMBER_OF_IMAGES] = {
  RESOURCE_ID_IMAGE_NUM_0_72, RESOURCE_ID_IMAGE_NUM_1_72, RESOURCE_ID_IMAGE_NUM_2_72,
  RESOURCE_ID_IMAGE_NUM_3_72, RESOURCE_ID_IMAGE_NUM_4_72, RESOURCE_ID_IMAGE_NUM_5_72,
  RESOURCE_ID_IMAGE_NUM_6_72, RESOURCE_ID_IMAGE_NUM_7_72, RESOURCE_ID_IMAGE_NUM_8_72,
  RESOURCE_ID_IMAGE_NUM_9_72
};

const int IMAGE_RESOURCE_IDS_84[NUMBER_OF_IMAGES] = {
  RESOURCE_ID_IMAGE_NUM_0_84, RESOURCE_ID_IMAGE_NUM_1_84, RESOURCE_ID_IMAGE_NUM_2_84,
  RESOURCE_ID_IMAGE_NUM_3_84, RESOURCE_ID_IMAGE_NUM_4_84, RESOURCE_ID_IMAGE_NUM_5_84,
  RESOURCE_ID_IMAGE_NUM_6_84, RESOURCE_ID_IMAGE_NUM_7_84, RESOURCE_ID_IMAGE_NUM_8_84,
  RESOURCE_ID_IMAGE_NUM_9_84
};

static GFont font_nevis_50;

static int backgroundBlack = 0;
static int showDay = 0;

static GBitmap *images[TOTAL_IMAGE_SLOTS];
static BitmapLayer *image_layers[TOTAL_IMAGE_SLOTS];

#define EMPTY_SLOT -1

// The state is either "empty" or the digit of the image currently in
// the slot--which was going to be used to assist with de-duplication
// but we're not doing that due to the one parent-per-layer
// restriction mentioned above.
static int image_slot_state[TOTAL_IMAGE_SLOTS] = {EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT};

static void load_digit_image_into_slot(int slot_number, int digit_value) {
  /*

     Loads the digit image from the application's resources and
     displays it on-screen in the correct location.

     Each slot is a quarter of the screen.

   */

  // TODO: Signal these error(s)?

  if ((slot_number < 0) || (slot_number >= TOTAL_IMAGE_SLOTS)) {
    return;
  }

  if ((digit_value < 0) || (digit_value > 9)) {
    return;
  }

  if (image_slot_state[slot_number] != EMPTY_SLOT) {
    return;
  }

  image_slot_state[slot_number] = digit_value;
  const int *IMAGE_RESOURCE_IDS = showDay ? IMAGE_RESOURCE_IDS_72 : IMAGE_RESOURCE_IDS_84;
  images[slot_number] = gbitmap_create_with_resource(IMAGE_RESOURCE_IDS[digit_value]);
  GRect frame = (GRect) {
    .origin = { (slot_number % 2) * 72, (slot_number / 2) * (showDay ? 72 : 84) },
    .size = images[slot_number]->bounds.size
  };
  BitmapLayer *bitmap_layer = bitmap_layer_create(frame);
  image_layers[slot_number] = bitmap_layer;
  bitmap_layer_set_bitmap(bitmap_layer, images[slot_number]);
  //Layer *window_layer = window_get_root_layer(window);
  layer_add_child(firstLayer, bitmap_layer_get_layer(bitmap_layer));
}

static void unload_digit_image_from_slot(int slot_number) {
  /*

     Removes the digit from the display and unloads the image resource
     to free up RAM.

     Can handle being called on an already empty slot.

   */

  if (image_slot_state[slot_number] != EMPTY_SLOT) {
    layer_remove_from_parent(bitmap_layer_get_layer(image_layers[slot_number]));
    bitmap_layer_destroy(image_layers[slot_number]);
    gbitmap_destroy(images[slot_number]);
    image_slot_state[slot_number] = EMPTY_SLOT;
  }

}

static void display_value(unsigned short value, unsigned short row_number, bool show_first_leading_zero) {
  /*

     Displays a numeric value between 0 and 99 on screen.

     Rows are ordered on screen as:

       Row 0
       Row 1

     Includes optional blanking of first leading zero,
     i.e. displays ' 0' rather than '00'.

   */
  value = value % 100; // Maximum of two digits per row.

  // Column order is: | Column 0 | Column 1 |
  // (We process the columns in reverse order because that makes
  // extracting the digits from the value easier.)
  for (int column_number = 1; column_number >= 0; column_number--) {
    int slot_number = (row_number * 2) + column_number;
    unload_digit_image_from_slot(slot_number);
    if (!((value == 0) && (column_number == 0) && !show_first_leading_zero)) {
      load_digit_image_into_slot(slot_number, value % 10);
    }
    value = value / 10;
  }
}

static unsigned short get_display_hour(unsigned short hour) {

  if (clock_is_24h_style()) {
    return hour;
  }

  unsigned short display_hour = hour % 12;

  // Converts "0" to "12"
  return display_hour ? display_hour : 12;

}

static void display_time(struct tm *tick_time) {

  // TODO: Use `units_changed` and more intelligence to reduce
  //       redundant digit unload/load?

  display_value(get_display_hour(tick_time->tm_hour), 0, false);
  display_value(tick_time->tm_min, 1, true); 
  snprintf(dayText, 3, "%2.2d", tick_time->tm_mday); 
  text_layer_set_text(dayLayer, showDay ? dayText : "  ");
}

static void handle_minute_tick(struct tm *tick_time, TimeUnits units_changed) {
  display_time(tick_time);
} 

static void loadPersistentValues() {
  backgroundBlack = persist_exists(PERSIST_KEY_BACKGROUND) ? persist_read_int(PERSIST_KEY_BACKGROUND) : DEFAULT_BACKGROUND;
  showDay = persist_exists(PERSIST_KEY_SHOW_DAY) ? persist_read_int(PERSIST_KEY_SHOW_DAY) : DEFAULT_SHOWDAY;
  APP_LOG(APP_LOG_LEVEL_DEBUG, "Loaded values from storage - background=%d, showDay=%d",
		  persist_exists(PERSIST_KEY_BACKGROUND) ? backgroundBlack : -1,
		  persist_exists(PERSIST_KEY_SHOW_DAY)? showDay : -1);
}                      

static void savePersistentValues() {
  status_t bgResult = persist_write_int(PERSIST_KEY_BACKGROUND, backgroundBlack);
  status_t sdResult = persist_write_int(PERSIST_KEY_SHOW_DAY, showDay);
  APP_LOG(APP_LOG_LEVEL_DEBUG, "Persisted values background=%d, showDay=%d, bgResult=%ld, sdResult=%ld", backgroundBlack, showDay, bgResult, sdResult);
}

void out_failed_handler(DictionaryIterator *failed, AppMessageResult reason, void *context) {
  APP_LOG(APP_LOG_LEVEL_DEBUG, "Message out failed because of %d", (int)reason); 
}           
            
static void sendDefaultsToJS();
     
void timerCallback(void *data) {
  sendDefaultsToJS();
}

static void sendDefaultsToJS() {
  DictionaryIterator *iter;
  AppMessageResult result = app_message_outbox_begin(&iter);
  
  if (iter == NULL) {
     APP_LOG(APP_LOG_LEVEL_DEBUG, "app message begin resulted in null pointer.  Cause=%d", result); 
     if (result == APP_MSG_BUSY)
        APP_LOG(APP_LOG_LEVEL_DEBUG, "That's APP_MSG_BUSY");
     app_timer_register(5000, timerCallback, NULL); 
     return;
  }

  Tuplet bgValue = TupletInteger(MSG_KEY_BACKGROUND, backgroundBlack);
  dict_write_tuplet(iter, &bgValue);

  Tuplet sdValue = TupletInteger(MSG_KEY_SHOW_DAY, 0);
  dict_write_tuplet(iter, &sdValue); 

  dict_write_end(iter);
                      
  APP_LOG(APP_LOG_LEVEL_DEBUG, "About to send app message");
  app_message_outbox_send();
}

static void setupBackground() {
   if (backgroundBlack) {
      if (inverterLayer) {
         layer_remove_from_parent(inverter_layer_get_layer(inverterLayer));
         inverter_layer_destroy(inverterLayer);
         inverterLayer = NULL;
      }
   } else {
      if (inverterLayer == NULL) {
         Layer *root_layer = window_get_root_layer(window);
         inverterLayer = inverter_layer_create(layer_get_frame(root_layer));
         layer_add_child(root_layer, inverter_layer_get_layer(inverterLayer));
      }
   }
}

static void drawCurrentTime() {
	time_t now = time(NULL);
	struct tm *tick_time = localtime(&now);
	display_time(tick_time);
}

static void in_received_handler(DictionaryIterator *iter, void *context) {
  Tuple *tuple = dict_read_first(iter);
  while (tuple) {   
    APP_LOG(APP_LOG_LEVEL_DEBUG, "Pebble received message with key %u", (unsigned)tuple->key);
    switch (tuple->key) {
      case 3:
        APP_LOG(APP_LOG_LEVEL_DEBUG, "Pebble received message requesting value update");
        sendDefaultsToJS();
        return; // don't save values on request  
      case 0:
        APP_LOG(APP_LOG_LEVEL_DEBUG, "Pebble received message with new background value");
        backgroundBlack = tuple->value->int8;
        break;
      case 1:
        APP_LOG(APP_LOG_LEVEL_DEBUG, "Pebble received message with new show day value");
        showDay = tuple->value->int8;
        break;
    }
    tuple = dict_read_next(iter);
  }
  APP_LOG(APP_LOG_LEVEL_DEBUG, "Pebble received message: background=%d, showDay=%d", backgroundBlack, showDay);
  
  // If not MSG_KEY_REQ_VALUES, then really expect both other keys to be present
  setupBackground();
  drawCurrentTime();
  savePersistentValues();
}

char* getDebugTimeString() {
	static char result[10];

	time_t now = time(NULL);
	struct tm *tick_time = localtime(&now);

	strftime(result, sizeof(result), "%I:%M:%S", tick_time);
	return result;
}

char* getDateString() {
	static char result[10];

	time_t now = time(NULL);
	struct tm *tick_time = localtime(&now);

	strftime(result, sizeof(result), "%m/%d", tick_time);
	return result;
}


static TextLayer *dateLayer;

static void tap_window_unload(Window *window) {
	if (dateLayer) {
		text_layer_destroy(dateLayer);
	}
	window_destroy(window);
	dateLayer = NULL;
}

void tap_timeout_handler(void *ptr) {
	window_stack_pop(true);
}

void accel_tap_handler(AccelAxisType axis, int32_t direction) {
  // Process tap on ACCEL_AXIS_X, ACCEL_AXIS_Y or ACCEL_AXIS_Z
  // Direction is 1 or -1
	//APP_LOG(APP_LOG_LEVEL_DEBUG, "Tap on axis %d with direction %ld at %s", axis, direction, getDebugTimeString());

	if (!dateLayer) {
		Window *tapWindow = window_create();
		window_set_background_color(tapWindow, GColorBlack);


		Layer *root_layer = window_get_root_layer(tapWindow);
		GRect bounds = layer_get_frame(root_layer);
		dateLayer = text_layer_create(GRect(0, (bounds.size.h/2) - 25, bounds.size.w, 60));

		text_layer_set_background_color(dateLayer, GColorBlack);
		text_layer_set_text_color(dateLayer, GColorWhite);
		text_layer_set_font(dateLayer, font_nevis_50);
		text_layer_set_text_alignment(dateLayer, GTextAlignmentCenter);
		layer_add_child(root_layer, text_layer_get_layer(dateLayer));

		text_layer_set_text(dateLayer, getDateString());

		window_set_window_handlers(tapWindow, (WindowHandlers) {
				.unload = tap_window_unload
		});
		window_stack_push(tapWindow, true);

		app_timer_register(2000, tap_timeout_handler, NULL);
	}
}


static void init() {
  window = window_create();
  window_set_background_color(window, GColorBlack);   
  app_message_open(64, 64);

  window_stack_push(window, true);
                                       
  loadPersistentValues();     

  app_message_register_inbox_received(in_received_handler);
  app_message_register_outbox_failed(out_failed_handler);
  sendDefaultsToJS();
                                         
  // initialize layer for day text
  GFont font = fonts_load_custom_font(resource_get_handle(RESOURCE_ID_FONT_NEVIS_20));
  font_nevis_50 = fonts_load_custom_font(resource_get_handle(RESOURCE_ID_FONT_NEVIS_50));

  Layer *root_layer = window_get_root_layer(window);
  GRect frame = layer_get_frame(root_layer); 
  firstLayer = layer_create(frame);
  layer_add_child(root_layer, firstLayer);
  
  setupBackground();
  
  //todo - make text layer conditional on show date
  dayLayer = text_layer_create((GRect) { .origin = { 0, frame.size.h-20 -DATE_OFFSET}, .size = { frame.size.w-DATE_OFFSET, 20 } });

  text_layer_set_background_color(dayLayer, GColorBlack);
  text_layer_set_text_color(dayLayer, GColorWhite);
  text_layer_set_font(dayLayer, font);
  text_layer_set_text_alignment(dayLayer, GTextAlignmentRight);
  layer_add_child(firstLayer, text_layer_get_layer(dayLayer));  
                              
  // Avoids a blank screen on watch start.
  drawCurrentTime();

  //accel_tap_service_subscribe(accel_tap_handler);
  //accel_service_set_sampling_rate(ACCEL_SAMPLING_100HZ);

  tap_subscribe(accel_tap_handler);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);
}

static void deinit() {
  for (int i = 0; i < TOTAL_IMAGE_SLOTS; i++) {
    unload_digit_image_from_slot(i);
  }                                

  accel_data_service_unsubscribe();
  text_layer_destroy(dayLayer);
  window_destroy(window);
}

int main(void) {
  init();
  app_event_loop();
  deinit();
}
